---
title: "Reduction and NP-complete"
layout: post
use_math: true
tags: ["Algorithm"]
---

## 서론

2020-1학기, 대학에서 '알고리즘' 수업을 듣고 공부한 바를 정리한 글입니다. 지적은 언제나 환영입니다 :)

- [(Review) P and NP](#review-p-and-np)
- [Reduction](#reduction)
  - [NP-complete](#np-complete)

<hr/>

## (Review) P and NP

![P-and-NP](https://media.geeksforgeeks.org/wp-content/uploads/NP-Completeness-1.png)

잠깐 이전 내용을 복습해보자.

- $\textbf{NP}$: the class of all search problems
- $\textbf{P}$: the class of all search problems that can be **solved in polynomial time**.

그리고 $\textbf{P} = \textbf{NP}$ 인지 $\textbf{P} \neq \textbf{NP}$ 인지에 대한 논쟁도 잠깐 다뤘다. 대부분의 연구자들은 $\textbf{P} \neq \textbf{NP}$라고 믿고 있다. 그러나 $\textbf{P} \neq \textbf{NP}$임을 밝히는 명확한 증명이 있는 건 아니다. 그들은 왜 $\textbf{P} \neq \textbf{NP}$라고 믿는 걸까?

그들은 '증거'를 가지고 있기 때문이다! $\textbf{NP}$에 속하는 몇몇 search problem은 몇십년, 몇백년이 걸려도 효율적인 알고리즘을 찾을 수 없었다는 **경험적인 증거**가 있다. 또, 하나의 증거는 **환원(Reduction)**으로, 그런 hardest problem들이 **equivalent under reduction**라는 것이 증명 되었기 때문이다!

> What *reudctions* demonstrate is that the problems are all, in some sense, exactly the same problem, except that tey are stated in different languages.

이번 챕터에서는 $\textbf{NP}$의 hardest problem들이 어떻게 equivalent under reduction 한지 가볍게 살펴보겠다.

<hr/>

## Reduction

<div class="img-wrapper">
  <img src="{{ "/images/algorithm/reduction-2.png" | relative_url }}" width="100%">
</div>

<div class="definition" markdown="1">

<span class="statement-title">Definition.</span> Reduction (search problem)<br>

A *reduction* from search problem $A$ to search problem $B$ is a polynomial-time algorithm $f$ that transforms any instance $I$ of $A$ into an instance $f(I)$ of $B$.

Together with another polynomial-time algorithm $h$ that maps any solution $S$ of $f(I)$ back into a solution $S$ of $f(I)$ back into a solution $h(S)$ of $I$.

</div>

즉, \<Reduction\>이라 함은 

- instance $I$를 변환(transform) 하는 polynomial-time algorithm $f$
- $f(I)$의 solution $S$를 $I$의 solution으로 변환하는 polynomial-time algorithm $h$

즉 $f$와 $h$, 2가지 알고리즘이 필요한 작업이다!

<br/>

그런데 \<Reduction\>을 하는 이유가 뭘까? 거기엔 2가지 목적이 있다.

1. We know how to solve $B$ efficiently, and want to utilize it to solve $A$
2. We know $A$ is hard, and use the reuction to prove $B$ is hard as well.

보통의 경우들에는 목적 1을 이루기 위해 \<Reduction\> 작업을 수행한다. 그러나 이번 경우에는 주어진 Search Problem 들이 어렵다는 걸 보이는 것을 목적으로 하는 목적 2를 위해서 \<Reduction\> 작업을 수행한다!!

### NP-complete

이제 \<Reduction\>이 무엇인지 대충 알았으니 $\textbf{NP-complete}$의 개념을 정의해보겠다. 

<div class="definition" markdown="1">

<span class="statement-title">Definition.</span> $\textbf{NP-complete}$<br>

A search problem is $\textbf{NP-complete}$ if all other search problems reduce to it.

</div>

텍스트와 함께 아래 그림을 살펴보자.

<div class="img-wrapper">
  <img src="{{ "/images/algorithm/reduction-1.png" | relative_url }}" width="100%">
</div>

위 그림을 보면, 모든 Search Problem, 즉 $\textbf{NP}$ 문제가 \<SAT\>로 reduction 되는 걸 볼 수 있다. 따라서 \<SAT\>는 $\textbf{NP-complete}$다. 그외에 우리가 살펴봤던 \<3-SAT\>, \<Independent Set Problem\> 등이 일련의 Reduction을 거쳐서 다시 \<SAT\>로 환원된다. 따라서 위 그림에 등장하는 Search Problem 모두 $\textbf{NP-complete}$다!

사실 위 그림을 진정으로 이해하려면, \<Reduction\>이 composition property를 갖는다는 사실을 알아야 한다.

<div class="statement" markdown="1">

For reduction,

If $A \rightarrow B$ and $B \rightarrow C$, then $A \rightarrow C$

</div>

<hr/>

자! 이제 몇 편의 포스트에 걸쳐서 이제껏 살펴봤던 $\textbf{NP}$ 문제들이 어떻게 서로 \<Reduction\> 되는지 살펴볼 것이다.

- Reduction - (2)
- Reduction - (3)
- Reduction - (4)

## 함께보기

- [P and NP]({{"/2022/01/14/P-and-NP.html" | relative_url}})